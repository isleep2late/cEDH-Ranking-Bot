"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/util.ts
var util_exports = {};
__export(util_exports, {
  default: () => util_default,
  gamma: () => gamma,
  ladderPairs: () => ladderPairs,
  rankings: () => rankings,
  score: () => score,
  sum: () => sum,
  utilA: () => utilA,
  utilSumQ: () => utilSumQ
});
module.exports = __toCommonJS(util_exports);
var import_ramda = require("ramda");

// src/constants.ts
var builder = (options) => {
  const { z = 3, mu = 25, preventSigmaIncrease = false, epsilon = 1e-4 } = options;
  const { tau = mu / 300, sigma = mu / z, beta = sigma / 2, limitSigma = preventSigmaIncrease } = options;
  const betaSq = beta ** 2;
  return {
    SIGMA: sigma,
    MU: mu,
    EPSILON: epsilon,
    TWOBETASQ: 2 * betaSq,
    BETA: beta,
    BETASQ: betaSq,
    Z: z,
    TAU: tau,
    LIMIT_SIGMA: limitSigma
  };
};
var constants_default = builder;

// src/util.ts
var sum = (a, b) => a + b;
var score = (q, i) => {
  if (q < i) {
    return 0;
  }
  if (q > i) {
    return 1;
  }
  return 0.5;
};
var rankings = (teams, rank = []) => {
  const teamScores = teams.map((_, i) => rank[i] || i);
  const outRank = new Array(teams.length);
  let s = 0;
  for (let j = 0; j < teamScores.length; j += 1) {
    if (j > 0 && teamScores[j - 1] < teamScores[j]) {
      s = j;
    }
    outRank[j] = s;
  }
  return outRank;
};
var teamRating = (options) => (game) => {
  const rank = rankings(game, options.rank);
  return game.map((team, i) => [
    // mu[i]
    team.map(({ mu }) => mu).reduce(sum, 0),
    // sigma^2[i]
    team.map(({ sigma }) => sigma * sigma).reduce(sum, 0),
    // (original team data)
    team,
    // rank[i]
    rank[i]
  ]);
};
var ladderPairs = (ranks) => {
  const size = ranks.length;
  const left = [void 0, ...ranks.slice(0, size - 1)];
  const right = [...ranks.slice(1), void 0];
  return (0, import_ramda.zip)(left, right).map(([l, r]) => {
    if (l !== void 0 && r !== void 0) return [l, r];
    if (l !== void 0 && r === void 0) return [l];
    if (l === void 0 && r !== void 0) return [r];
    return [];
  });
};
var utilC = (options) => {
  const { BETASQ } = constants_default(options);
  return (teamRatings) => Math.sqrt(teamRatings.map(([_teamMu, teamSigmaSq, _team, _rank]) => teamSigmaSq + BETASQ).reduce(sum, 0));
};
var utilSumQ = (teamRatings, c) => teamRatings.map(
  ([_qMu, _qSigmaSq, _qTeam, qRank]) => teamRatings.filter(([_iMu, _iSigmaSq, _iTeam, iRank]) => iRank >= qRank).map(([iMu, _iSigmaSq, _iTeam, _iRank]) => Math.exp(iMu / c)).reduce(sum, 0)
);
var utilA = (teamRatings) => teamRatings.map(
  ([_iMu, _iSigmaSq, _iTeam, iRank]) => teamRatings.filter(([_qMu, _qSigmaSq, _qTeam, qRank]) => iRank === qRank).length
);
var gamma = (options) => {
  var _a;
  return (_a = options.gamma) != null ? _a : (
    // default to iSigma / c
    (c, _k, _mu, sigmaSq, _team, _qRank) => Math.sqrt(sigmaSq) / c
  );
};
var util_default = (options) => ({
  utilC: utilC(options),
  teamRating: teamRating(options),
  gamma: gamma(options)
});
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  gamma,
  ladderPairs,
  rankings,
  score,
  sum,
  utilA,
  utilSumQ
});
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vc3JjL3V0aWwudHMiLCAiLi4vc3JjL2NvbnN0YW50cy50cyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiaW1wb3J0IHsgemlwIH0gZnJvbSAncmFtZGEnXG5pbXBvcnQgY29uc3RhbnRzIGZyb20gJy4vY29uc3RhbnRzJ1xuaW1wb3J0IHsgUmF0aW5nLCBPcHRpb25zLCBHYW1tYSwgVGVhbSwgUmFuayB9IGZyb20gJy4vdHlwZXMnXG5cbmV4cG9ydCB0eXBlIFRlYW1NdSA9IG51bWJlclxuXG5leHBvcnQgdHlwZSBUZWFtU2lnbWFTcSA9IG51bWJlclxuXG5leHBvcnQgdHlwZSBUZWFtUmF0aW5nID0gW1RlYW1NdSwgVGVhbVNpZ21hU3EsIFRlYW0sIFJhbmtdXG5cbmV4cG9ydCBjb25zdCBzdW0gPSAoYTogbnVtYmVyLCBiOiBudW1iZXIpID0+IGEgKyBiXG5cbmV4cG9ydCBjb25zdCBzY29yZSA9IChxOiBudW1iZXIsIGk6IG51bWJlcikgPT4ge1xuICBpZiAocSA8IGkpIHtcbiAgICByZXR1cm4gMC4wXG4gIH1cbiAgaWYgKHEgPiBpKSB7XG4gICAgcmV0dXJuIDEuMFxuICB9XG4gIC8vIHEgPT09IGlcbiAgcmV0dXJuIDAuNVxufVxuXG5leHBvcnQgY29uc3QgcmFua2luZ3MgPSAodGVhbXM6IFRlYW1bXSwgcmFuazogbnVtYmVyW10gPSBbXSkgPT4ge1xuICBjb25zdCB0ZWFtU2NvcmVzID0gdGVhbXMubWFwKChfLCBpKSA9PiByYW5rW2ldIHx8IGkpXG4gIGNvbnN0IG91dFJhbmsgPSBuZXcgQXJyYXkodGVhbXMubGVuZ3RoKVxuXG4gIGxldCBzID0gMFxuICBmb3IgKGxldCBqID0gMDsgaiA8IHRlYW1TY29yZXMubGVuZ3RoOyBqICs9IDEpIHtcbiAgICBpZiAoaiA+IDAgJiYgdGVhbVNjb3Jlc1tqIC0gMV0gPCB0ZWFtU2NvcmVzW2pdKSB7XG4gICAgICBzID0galxuICAgIH1cbiAgICBvdXRSYW5rW2pdID0gc1xuICB9XG4gIHJldHVybiBvdXRSYW5rXG59XG5cbi8vIHRoaXMgaXMgYmFzaWNhbGx5IHNoYXJlZCBjb2RlLCBwcmVjb21wdXRlZCBmb3IgZXZlcnkgbW9kZWxcbmNvbnN0IHRlYW1SYXRpbmcgPVxuICAob3B0aW9uczogT3B0aW9ucykgPT5cbiAgKGdhbWU6IFRlYW1bXSk6IFRlYW1SYXRpbmdbXSA9PiB7XG4gICAgY29uc3QgcmFuayA9IHJhbmtpbmdzKGdhbWUsIG9wdGlvbnMucmFuaylcbiAgICByZXR1cm4gZ2FtZS5tYXAoKHRlYW0sIGkpID0+IFtcbiAgICAgIC8vIG11W2ldXG4gICAgICB0ZWFtLm1hcCgoeyBtdSB9KSA9PiBtdSkucmVkdWNlKHN1bSwgMCksXG4gICAgICAvLyBzaWdtYV4yW2ldXG4gICAgICB0ZWFtLm1hcCgoeyBzaWdtYSB9KSA9PiBzaWdtYSAqIHNpZ21hKS5yZWR1Y2Uoc3VtLCAwKSxcbiAgICAgIC8vIChvcmlnaW5hbCB0ZWFtIGRhdGEpXG4gICAgICB0ZWFtLFxuICAgICAgLy8gcmFua1tpXVxuICAgICAgcmFua1tpXSxcbiAgICBdKVxuICB9XG5cbmV4cG9ydCBjb25zdCBsYWRkZXJQYWlycyA9IDxUPihyYW5rczogVFtdKTogVFtdW10gPT4ge1xuICBjb25zdCBzaXplID0gcmFua3MubGVuZ3RoXG4gIGNvbnN0IGxlZnQgPSBbdW5kZWZpbmVkLCAuLi5yYW5rcy5zbGljZSgwLCBzaXplIC0gMSldXG4gIGNvbnN0IHJpZ2h0ID0gWy4uLnJhbmtzLnNsaWNlKDEpLCB1bmRlZmluZWRdXG4gIHJldHVybiB6aXAobGVmdCwgcmlnaHQpLm1hcCgoW2wsIHJdKSA9PiB7XG4gICAgaWYgKGwgIT09IHVuZGVmaW5lZCAmJiByICE9PSB1bmRlZmluZWQpIHJldHVybiBbbCwgcl1cbiAgICBpZiAobCAhPT0gdW5kZWZpbmVkICYmIHIgPT09IHVuZGVmaW5lZCkgcmV0dXJuIFtsXVxuICAgIGlmIChsID09PSB1bmRlZmluZWQgJiYgciAhPT0gdW5kZWZpbmVkKSByZXR1cm4gW3JdXG4gICAgcmV0dXJuIFtdIC8vIHRoaXMgc2hvdWxkIHJlYWxseSBvbmx5IGhhcHBlbiB3aGVuIHNpemUgPT09IDFcbiAgfSlcbn1cblxuY29uc3QgdXRpbEMgPSAob3B0aW9uczogT3B0aW9ucykgPT4ge1xuICBjb25zdCB7IEJFVEFTUSB9ID0gY29uc3RhbnRzKG9wdGlvbnMpXG4gIHJldHVybiAodGVhbVJhdGluZ3M6IFRlYW1SYXRpbmdbXSkgPT5cbiAgICBNYXRoLnNxcnQodGVhbVJhdGluZ3MubWFwKChbX3RlYW1NdSwgdGVhbVNpZ21hU3EsIF90ZWFtLCBfcmFua10pID0+IHRlYW1TaWdtYVNxICsgQkVUQVNRKS5yZWR1Y2Uoc3VtLCAwKSlcbn1cblxuZXhwb3J0IGNvbnN0IHV0aWxTdW1RID0gKHRlYW1SYXRpbmdzOiBUZWFtUmF0aW5nW10sIGM6IG51bWJlcikgPT5cbiAgdGVhbVJhdGluZ3MubWFwKChbX3FNdSwgX3FTaWdtYVNxLCBfcVRlYW0sIHFSYW5rXSkgPT5cbiAgICB0ZWFtUmF0aW5nc1xuICAgICAgLmZpbHRlcigoW19pTXUsIF9pU2lnbWFTcSwgX2lUZWFtLCBpUmFua10pID0+IGlSYW5rID49IHFSYW5rKVxuICAgICAgLm1hcCgoW2lNdSwgX2lTaWdtYVNxLCBfaVRlYW0sIF9pUmFua10pID0+IE1hdGguZXhwKGlNdSAvIGMpKVxuICAgICAgLnJlZHVjZShzdW0sIDApXG4gIClcblxuZXhwb3J0IGNvbnN0IHV0aWxBID0gKHRlYW1SYXRpbmdzOiBUZWFtUmF0aW5nW10pID0+XG4gIHRlYW1SYXRpbmdzLm1hcChcbiAgICAoW19pTXUsIF9pU2lnbWFTcSwgX2lUZWFtLCBpUmFua10pID0+XG4gICAgICB0ZWFtUmF0aW5ncy5maWx0ZXIoKFtfcU11LCBfcVNpZ21hU3EsIF9xVGVhbSwgcVJhbmtdKSA9PiBpUmFuayA9PT0gcVJhbmspLmxlbmd0aFxuICApXG5cbmV4cG9ydCBjb25zdCBnYW1tYSA9IChvcHRpb25zOiBPcHRpb25zKTogR2FtbWEgPT5cbiAgb3B0aW9ucy5nYW1tYSA/P1xuICAvLyBkZWZhdWx0IHRvIGlTaWdtYSAvIGNcbiAgKChjOiBudW1iZXIsIF9rOiBudW1iZXIsIF9tdTogbnVtYmVyLCBzaWdtYVNxOiBudW1iZXIsIF90ZWFtOiBSYXRpbmdbXSwgX3FSYW5rOiBudW1iZXIpID0+IE1hdGguc3FydChzaWdtYVNxKSAvIGMpXG5cbmV4cG9ydCBkZWZhdWx0IChvcHRpb25zOiBPcHRpb25zKSA9PiAoe1xuICB1dGlsQzogdXRpbEMob3B0aW9ucyksXG4gIHRlYW1SYXRpbmc6IHRlYW1SYXRpbmcob3B0aW9ucyksXG4gIGdhbW1hOiBnYW1tYShvcHRpb25zKSxcbn0pXG4iLCAiaW1wb3J0IHsgT3B0aW9ucyB9IGZyb20gJy4vdHlwZXMnXG5cbmNvbnN0IGJ1aWxkZXIgPSAob3B0aW9uczogT3B0aW9ucykgPT4ge1xuICAvLyBpJ2QgbG92ZSB0byBrbm93IG9mIGEgYmV0dGVyIHdheSB0byBkbyB0aGlzXG4gIGNvbnN0IHsgeiA9IDMsIG11ID0gMjUsIHByZXZlbnRTaWdtYUluY3JlYXNlID0gZmFsc2UsIGVwc2lsb24gPSAwLjAwMDEgfSA9IG9wdGlvbnNcbiAgY29uc3QgeyB0YXUgPSBtdSAvIDMwMCwgc2lnbWEgPSBtdSAvIHosIGJldGEgPSBzaWdtYSAvIDIsIGxpbWl0U2lnbWEgPSBwcmV2ZW50U2lnbWFJbmNyZWFzZSB9ID0gb3B0aW9uc1xuICBjb25zdCBiZXRhU3EgPSBiZXRhICoqIDJcblxuICByZXR1cm4ge1xuICAgIFNJR01BOiBzaWdtYSxcbiAgICBNVTogbXUsXG4gICAgRVBTSUxPTjogZXBzaWxvbixcbiAgICBUV09CRVRBU1E6IDIgKiBiZXRhU3EsXG4gICAgQkVUQTogYmV0YSxcbiAgICBCRVRBU1E6IGJldGFTcSxcbiAgICBaOiB6LFxuICAgIFRBVTogdGF1LFxuICAgIExJTUlUX1NJR01BOiBsaW1pdFNpZ21hLFxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJ1aWxkZXJcbiJdLAogICJtYXBwaW5ncyI6ICI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FB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