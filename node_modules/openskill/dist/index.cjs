"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  ordinal: () => ordinal_default,
  predictDraw: () => predict_draw_default,
  predictWin: () => predict_win_default,
  rate: () => rate_default,
  rating: () => rating_default
});
module.exports = __toCommonJS(src_exports);

// src/constants.ts
var builder = (options) => {
  const { z = 3, mu = 25, preventSigmaIncrease = false, epsilon = 1e-4 } = options;
  const { tau = mu / 300, sigma = mu / z, beta = sigma / 2, limitSigma = preventSigmaIncrease } = options;
  const betaSq = beta ** 2;
  return {
    SIGMA: sigma,
    MU: mu,
    EPSILON: epsilon,
    TWOBETASQ: 2 * betaSq,
    BETA: beta,
    BETASQ: betaSq,
    Z: z,
    TAU: tau,
    LIMIT_SIGMA: limitSigma
  };
};
var constants_default = builder;

// src/rating.ts
var rating = (init, options = {}) => {
  const { MU: mu, SIGMA: sigma } = constants_default(__spreadValues(__spreadValues({}, options), init));
  return { mu, sigma };
};
var rating_default = rating;

// src/rate.ts
var import_ramda2 = require("ramda");
var import_sort_unwind = require("sort-unwind");

// src/util.ts
var import_ramda = require("ramda");
var sum = (a, b) => a + b;
var rankings = (teams, rank = []) => {
  const teamScores = teams.map((_, i) => rank[i] || i);
  const outRank = new Array(teams.length);
  let s = 0;
  for (let j = 0; j < teamScores.length; j += 1) {
    if (j > 0 && teamScores[j - 1] < teamScores[j]) {
      s = j;
    }
    outRank[j] = s;
  }
  return outRank;
};
var teamRating = (options) => (game) => {
  const rank = rankings(game, options.rank);
  return game.map((team, i) => [
    // mu[i]
    team.map(({ mu }) => mu).reduce(sum, 0),
    // sigma^2[i]
    team.map(({ sigma }) => sigma * sigma).reduce(sum, 0),
    // (original team data)
    team,
    // rank[i]
    rank[i]
  ]);
};
var utilC = (options) => {
  const { BETASQ } = constants_default(options);
  return (teamRatings) => Math.sqrt(teamRatings.map(([_teamMu, teamSigmaSq, _team, _rank]) => teamSigmaSq + BETASQ).reduce(sum, 0));
};
var utilSumQ = (teamRatings, c) => teamRatings.map(
  ([_qMu, _qSigmaSq, _qTeam, qRank]) => teamRatings.filter(([_iMu, _iSigmaSq, _iTeam, iRank]) => iRank >= qRank).map(([iMu, _iSigmaSq, _iTeam, _iRank]) => Math.exp(iMu / c)).reduce(sum, 0)
);
var utilA = (teamRatings) => teamRatings.map(
  ([_iMu, _iSigmaSq, _iTeam, iRank]) => teamRatings.filter(([_qMu, _qSigmaSq, _qTeam, qRank]) => iRank === qRank).length
);
var gamma = (options) => {
  var _a;
  return (_a = options.gamma) != null ? _a : (
    // default to iSigma / c
    (c, _k, _mu, sigmaSq, _team, _qRank) => Math.sqrt(sigmaSq) / c
  );
};
var util_default = (options) => ({
  utilC: utilC(options),
  teamRating: teamRating(options),
  gamma: gamma(options)
});

// src/models/plackett-luce.ts
var model = (game, options = {}) => {
  const { EPSILON } = constants_default(options);
  const { utilC: utilC2, teamRating: teamRating2, gamma: gamma2 } = util_default(options);
  const teamRatings = teamRating2(game);
  const c = utilC2(teamRatings);
  const sumQ = utilSumQ(teamRatings, c);
  const a = utilA(teamRatings);
  return teamRatings.map((iTeamRating, i) => {
    const [iMu, iSigmaSq, iTeam, iRank] = iTeamRating;
    const iMuOverCe = Math.exp(iMu / c);
    const [omegaSum, deltaSum] = teamRatings.filter(([_qMu, _qSigmaSq, _qTeam, qRank]) => qRank <= iRank).reduce(
      ([omega, delta], [_], q) => {
        const quotient = iMuOverCe / sumQ[q];
        return [omega + (i === q ? 1 - quotient : -quotient) / a[q], delta + quotient * (1 - quotient) / a[q]];
      },
      [0, 0]
    );
    const iGamma = gamma2(c, teamRatings.length, ...iTeamRating);
    const iOmega = omegaSum * (iSigmaSq / c);
    const iDelta = iGamma * deltaSum * (iSigmaSq / c ** 2);
    return iTeam.map(({ mu, sigma }) => ({
      mu: mu + sigma ** 2 / iSigmaSq * iOmega,
      sigma: sigma * Math.sqrt(Math.max(1 - sigma ** 2 / iSigmaSq * iDelta, EPSILON))
    }));
  });
};
var plackett_luce_default = model;

// src/statistics.ts
var import_gaussian = __toESM(require("gaussian"), 1);
var normal = (0, import_gaussian.default)(0, 1);
var phiMajor = (x) => normal.cdf(x);
var phiMajorInverse = (x) => normal.ppf(x);

// src/rate.ts
var rate = (teams, options = {}) => {
  var _a, _b, _c;
  const { LIMIT_SIGMA, TAU } = constants_default(options);
  const { model: model2 = plackett_luce_default } = options;
  let processedTeams = teams;
  if (options.tau) {
    const tauSquared = TAU * TAU;
    processedTeams = teams.map(
      (team) => team.map((p) => __spreadProps(__spreadValues({}, p), {
        sigma: Math.sqrt(p.sigma * p.sigma + tauSquared)
      }))
    );
  }
  const rank = (_c = (_b = options.rank) != null ? _b : (_a = options.score) == null ? void 0 : _a.map((points) => -points)) != null ? _c : (0, import_ramda2.range)(1, teams.length + 1);
  const [orderedTeams, tenet] = (0, import_sort_unwind.unwind)(rank, processedTeams);
  const newRatings = model2(orderedTeams, __spreadProps(__spreadValues({}, options), {
    rank: (0, import_ramda2.sortBy)(import_ramda2.identity, rank)
  }));
  let [reorderedTeams] = (0, import_sort_unwind.unwind)(tenet, newRatings);
  if (TAU && LIMIT_SIGMA) {
    reorderedTeams = reorderedTeams.map(
      (team, i) => team.map((p, j) => __spreadProps(__spreadValues({}, p), {
        sigma: Math.min(p.sigma, teams[i][j].sigma)
      }))
    );
  }
  return reorderedTeams;
};
var rate_default = rate;

// src/ordinal.ts
var ordinal = (rating2, options = {}) => {
  const { sigma, mu } = rating2;
  const { Z } = constants_default(options);
  return mu - Z * sigma;
};
var ordinal_default = ordinal;

// src/predict-win.ts
var predictWin = (teams, options = {}) => {
  const { teamRating: teamRating2 } = util_default(options);
  const { BETASQ } = constants_default(options);
  const teamRatings = teamRating2(teams);
  const n = teams.length;
  const denom = n * (n - 1) / 2;
  return teamRatings.map(
    ([muA, sigmaSqA], i) => teamRatings.filter((_, q) => i !== q).map(([muB, sigmaSqB]) => phiMajor((muA - muB) / Math.sqrt(n * BETASQ + sigmaSqA + sigmaSqB))).reduce(sum, 0) / denom
  );
};
var predict_win_default = predictWin;

// src/predict-draw.ts
var import_ramda3 = require("ramda");
var predictDraw = (teams, options = {}) => {
  const { teamRating: teamRating2 } = util_default(options);
  const { BETASQ, BETA } = constants_default(options);
  const totalPlayerCount = (0, import_ramda3.flatten)(teams).length;
  const drawProbability = 1 / totalPlayerCount;
  const drawMargin = Math.sqrt(totalPlayerCount) * BETA * phiMajorInverse((1 + drawProbability) / 2);
  const teamRatings = (0, import_ramda3.map)((team) => (0, import_ramda3.head)(teamRating2([team])), teams);
  const pairwiseProbs = (0, import_ramda3.addIndex)(import_ramda3.reduce)(
    (outerAccum, pairA, i) => {
      const [muA, sigmaSqA] = pairA;
      return (0, import_ramda3.reduce)(
        (innerAccum, pairB) => {
          const [muB, sigmaSqB] = pairB;
          const sharedDenom = Math.sqrt(totalPlayerCount * BETASQ + sigmaSqA + sigmaSqB);
          innerAccum.push(
            phiMajor((drawMargin - muA + muB) / sharedDenom) - phiMajor((muB - muA - drawMargin) / sharedDenom)
          );
          return innerAccum;
        },
        outerAccum,
        teamRatings.slice(i + 1)
      );
    },
    [],
    teamRatings
  );
  return (0, import_ramda3.sum)(pairwiseProbs) / pairwiseProbs.length;
};
var predict_draw_default = predictDraw;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ordinal,
  predictDraw,
  predictWin,
  rate,
  rating
});
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vc3JjL2luZGV4LnRzIiwgIi4uL3NyYy9jb25zdGFudHMudHMiLCAiLi4vc3JjL3JhdGluZy50cyIsICIuLi9zcmMvcmF0ZS50cyIsICIuLi9zcmMvdXRpbC50cyIsICIuLi9zcmMvbW9kZWxzL3BsYWNrZXR0LWx1Y2UudHMiLCAiLi4vc3JjL3N0YXRpc3RpY3MudHMiLCAiLi4vc3JjL29yZGluYWwudHMiLCAiLi4vc3JjL3ByZWRpY3Qtd2luLnRzIiwgIi4uL3NyYy9wcmVkaWN0LWRyYXcudHMiXSwKICAic291cmNlc0NvbnRlbnQiOiBbImV4cG9ydCB7IGRlZmF1bHQgYXMgcmF0aW5nIH0gZnJvbSAnLi9yYXRpbmcnXG5leHBvcnQgeyBkZWZhdWx0IGFzIHJhdGUgfSBmcm9tICcuL3JhdGUnXG5leHBvcnQgeyBkZWZhdWx0IGFzIG9yZGluYWwgfSBmcm9tICcuL29yZGluYWwnXG5leHBvcnQgeyBkZWZhdWx0IGFzIHByZWRpY3RXaW4gfSBmcm9tICcuL3ByZWRpY3Qtd2luJ1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBwcmVkaWN0RHJhdyB9IGZyb20gJy4vcHJlZGljdC1kcmF3J1xuZXhwb3J0ICogZnJvbSAnLi90eXBlcydcbiIsICJpbXBvcnQgeyBPcHRpb25zIH0gZnJvbSAnLi90eXBlcydcblxuY29uc3QgYnVpbGRlciA9IChvcHRpb25zOiBPcHRpb25zKSA9PiB7XG4gIC8vIGknZCBsb3ZlIHRvIGtub3cgb2YgYSBiZXR0ZXIgd2F5IHRvIGRvIHRoaXNcbiAgY29uc3QgeyB6ID0gMywgbXUgPSAyNSwgcHJldmVudFNpZ21hSW5jcmVhc2UgPSBmYWxzZSwgZXBzaWxvbiA9IDAuMDAwMSB9ID0gb3B0aW9uc1xuICBjb25zdCB7IHRhdSA9IG11IC8gMzAwLCBzaWdtYSA9IG11IC8geiwgYmV0YSA9IHNpZ21hIC8gMiwgbGltaXRTaWdtYSA9IHByZXZlbnRTaWdtYUluY3JlYXNlIH0gPSBvcHRpb25zXG4gIGNvbnN0IGJldGFTcSA9IGJldGEgKiogMlxuXG4gIHJldHVybiB7XG4gICAgU0lHTUE6IHNpZ21hLFxuICAgIE1VOiBtdSxcbiAgICBFUFNJTE9OOiBlcHNpbG9uLFxuICAgIFRXT0JFVEFTUTogMiAqIGJldGFTcSxcbiAgICBCRVRBOiBiZXRhLFxuICAgIEJFVEFTUTogYmV0YVNxLFxuICAgIFo6IHosXG4gICAgVEFVOiB0YXUsXG4gICAgTElNSVRfU0lHTUE6IGxpbWl0U2lnbWEsXG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgYnVpbGRlclxuIiwgImltcG9ydCBjb25zdGFudHMgZnJvbSAnLi9jb25zdGFudHMnXG5pbXBvcnQgeyBPcHRpb25zLCBSYXRpbmcgfSBmcm9tICcuL3R5cGVzJ1xuXG5jb25zdCByYXRpbmcgPSAoaW5pdD86IHsgbXU/OiBudW1iZXI7IHNpZ21hPzogbnVtYmVyIH0sIG9wdGlvbnM6IE9wdGlvbnMgPSB7fSk6IFJhdGluZyA9PiB7XG4gIGNvbnN0IHsgTVU6IG11LCBTSUdNQTogc2lnbWEgfSA9IGNvbnN0YW50cyh7IC4uLm9wdGlvbnMsIC4uLmluaXQgfSlcbiAgcmV0dXJuIHsgbXUsIHNpZ21hIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgcmF0aW5nXG4iLCAiaW1wb3J0IHsgc29ydEJ5LCBpZGVudGl0eSwgcmFuZ2UgfSBmcm9tICdyYW1kYSdcbmltcG9ydCB7IHVud2luZCB9IGZyb20gJ3NvcnQtdW53aW5kJ1xuXG5pbXBvcnQgeyBSYXRpbmcsIE9wdGlvbnMsIFRlYW0gfSBmcm9tICcuL3R5cGVzJ1xuaW1wb3J0IGNvbnN0YW50cyBmcm9tICcuL2NvbnN0YW50cydcbmltcG9ydCB7IHBsYWNrZXR0THVjZSB9IGZyb20gJy4vbW9kZWxzJ1xuXG5jb25zdCByYXRlID0gKHRlYW1zOiBUZWFtW10sIG9wdGlvbnM6IE9wdGlvbnMgPSB7fSk6IFRlYW1bXSA9PiB7XG4gIGNvbnN0IHsgTElNSVRfU0lHTUEsIFRBVSB9ID0gY29uc3RhbnRzKG9wdGlvbnMpXG4gIGNvbnN0IHsgbW9kZWwgPSBwbGFja2V0dEx1Y2UgfSA9IG9wdGlvbnNcbiAgbGV0IHByb2Nlc3NlZFRlYW1zID0gdGVhbXNcblxuICAvLyBpZiB0YXUgaXMgcHJvdmlkZWQsIHVzZSBhZGRpdGl2ZSBkeW5hbWljcyBmYWN0b3IgdG8gcHJldmVudCBzaWdtYSBmcm9tIGRyb3BwaW5nIHRvbyBsb3cuXG4gIC8vIHVzaW5nIHRoaXMgd2lsbCBlbnN1cmUgdGhlIHJhdGluZyB3aWxsIHN0YXkgbW9yZSBwbGlhYmxlIGFmdGVyIG1hbnkgZ2FtZXNcbiAgaWYgKG9wdGlvbnMudGF1KSB7XG4gICAgY29uc3QgdGF1U3F1YXJlZCA9IFRBVSAqIFRBVVxuICAgIHByb2Nlc3NlZFRlYW1zID0gdGVhbXMubWFwKCh0ZWFtKSA9PlxuICAgICAgdGVhbS5tYXAoKHApID0+ICh7XG4gICAgICAgIC4uLnAsXG4gICAgICAgIHNpZ21hOiBNYXRoLnNxcnQocC5zaWdtYSAqIHAuc2lnbWEgKyB0YXVTcXVhcmVkKSxcbiAgICAgIH0pKVxuICAgIClcbiAgfVxuXG4gIC8vIGlmIHJhbmsgcHJvdmlkZWQsIHVzZSBpdCwgb3RoZXJ3aXNlIHRyYW5zaXRpb24gc2NvcmVzIGFuZCB1c2UgdGhhdFxuICBjb25zdCByYW5rID0gb3B0aW9ucy5yYW5rID8/IG9wdGlvbnMuc2NvcmU/Lm1hcCgocG9pbnRzKSA9PiAtcG9pbnRzKSA/PyByYW5nZSgxLCB0ZWFtcy5sZW5ndGggKyAxKVxuXG4gIGNvbnN0IFtvcmRlcmVkVGVhbXMsIHRlbmV0XSA9IHVud2luZChyYW5rLCBwcm9jZXNzZWRUZWFtcylcbiAgY29uc3QgbmV3UmF0aW5ncyA9IG1vZGVsKG9yZGVyZWRUZWFtcywge1xuICAgIC4uLm9wdGlvbnMsXG4gICAgcmFuazogc29ydEJ5KGlkZW50aXR5LCByYW5rKSxcbiAgfSlcbiAgbGV0IFtyZW9yZGVyZWRUZWFtc10gPSB1bndpbmQodGVuZXQsIG5ld1JhdGluZ3MpXG5cbiAgLy8gbGltaXRTaWdtYSBwcmV2ZW50cyBzaWdtYSBmcm9tIGV2ZXIgZ29pbmcgdXAgd2hpY2ggY2FuIGhhcHBlbiB3aGVuIHVzaW5nIGEgdGF1IHZhbHVlLlxuICAvLyB0aGlzIGhlbHBzIHByZXZlbnQgb3JkaW5hbCBmcm9tIGV2ZXIgZHJvcHBpbmcgYWZ0ZXIgd2lubmluZyBhIGdhbWUgd2hpY2ggY2FuIGZlZWwgdW5mYWlyXG4gIGlmIChUQVUgJiYgTElNSVRfU0lHTUEpIHtcbiAgICByZW9yZGVyZWRUZWFtcyA9IHJlb3JkZXJlZFRlYW1zLm1hcCgodGVhbTogUmF0aW5nW10sIGk6IG51bWJlcikgPT5cbiAgICAgIHRlYW0ubWFwKChwLCBqKSA9PiAoe1xuICAgICAgICAuLi5wLFxuICAgICAgICBzaWdtYTogTWF0aC5taW4ocC5zaWdtYSwgdGVhbXNbaV1bal0uc2lnbWEpLFxuICAgICAgfSkpXG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIHJlb3JkZXJlZFRlYW1zXG59XG5cbmV4cG9ydCBkZWZhdWx0IHJhdGVcbiIsICJpbXBvcnQgeyB6aXAgfSBmcm9tICdyYW1kYSdcbmltcG9ydCBjb25zdGFudHMgZnJvbSAnLi9jb25zdGFudHMnXG5pbXBvcnQgeyBSYXRpbmcsIE9wdGlvbnMsIEdhbW1hLCBUZWFtLCBSYW5rIH0gZnJvbSAnLi90eXBlcydcblxuZXhwb3J0IHR5cGUgVGVhbU11ID0gbnVtYmVyXG5cbmV4cG9ydCB0eXBlIFRlYW1TaWdtYVNxID0gbnVtYmVyXG5cbmV4cG9ydCB0eXBlIFRlYW1SYXRpbmcgPSBbVGVhbU11LCBUZWFtU2lnbWFTcSwgVGVhbSwgUmFua11cblxuZXhwb3J0IGNvbnN0IHN1bSA9IChhOiBudW1iZXIsIGI6IG51bWJlcikgPT4gYSArIGJcblxuZXhwb3J0IGNvbnN0IHNjb3JlID0gKHE6IG51bWJlciwgaTogbnVtYmVyKSA9PiB7XG4gIGlmIChxIDwgaSkge1xuICAgIHJldHVybiAwLjBcbiAgfVxuICBpZiAocSA+IGkpIHtcbiAgICByZXR1cm4gMS4wXG4gIH1cbiAgLy8gcSA9PT0gaVxuICByZXR1cm4gMC41XG59XG5cbmV4cG9ydCBjb25zdCByYW5raW5ncyA9ICh0ZWFtczogVGVhbVtdLCByYW5rOiBudW1iZXJbXSA9IFtdKSA9PiB7XG4gIGNvbnN0IHRlYW1TY29yZXMgPSB0ZWFtcy5tYXAoKF8sIGkpID0+IHJhbmtbaV0gfHwgaSlcbiAgY29uc3Qgb3V0UmFuayA9IG5ldyBBcnJheSh0ZWFtcy5sZW5ndGgpXG5cbiAgbGV0IHMgPSAwXG4gIGZvciAobGV0IGogPSAwOyBqIDwgdGVhbVNjb3Jlcy5sZW5ndGg7IGogKz0gMSkge1xuICAgIGlmIChqID4gMCAmJiB0ZWFtU2NvcmVzW2ogLSAxXSA8IHRlYW1TY29yZXNbal0pIHtcbiAgICAgIHMgPSBqXG4gICAgfVxuICAgIG91dFJhbmtbal0gPSBzXG4gIH1cbiAgcmV0dXJuIG91dFJhbmtcbn1cblxuLy8gdGhpcyBpcyBiYXNpY2FsbHkgc2hhcmVkIGNvZGUsIHByZWNvbXB1dGVkIGZvciBldmVyeSBtb2RlbFxuY29uc3QgdGVhbVJhdGluZyA9XG4gIChvcHRpb25zOiBPcHRpb25zKSA9PlxuICAoZ2FtZTogVGVhbVtdKTogVGVhbVJhdGluZ1tdID0+IHtcbiAgICBjb25zdCByYW5rID0gcmFua2luZ3MoZ2FtZSwgb3B0aW9ucy5yYW5rKVxuICAgIHJldHVybiBnYW1lLm1hcCgodGVhbSwgaSkgPT4gW1xuICAgICAgLy8gbXVbaV1cbiAgICAgIHRlYW0ubWFwKCh7IG11IH0pID0+IG11KS5yZWR1Y2Uoc3VtLCAwKSxcbiAgICAgIC8vIHNpZ21hXjJbaV1cbiAgICAgIHRlYW0ubWFwKCh7IHNpZ21hIH0pID0+IHNpZ21hICogc2lnbWEpLnJlZHVjZShzdW0sIDApLFxuICAgICAgLy8gKG9yaWdpbmFsIHRlYW0gZGF0YSlcbiAgICAgIHRlYW0sXG4gICAgICAvLyByYW5rW2ldXG4gICAgICByYW5rW2ldLFxuICAgIF0pXG4gIH1cblxuZXhwb3J0IGNvbnN0IGxhZGRlclBhaXJzID0gPFQ+KHJhbmtzOiBUW10pOiBUW11bXSA9PiB7XG4gIGNvbnN0IHNpemUgPSByYW5rcy5sZW5ndGhcbiAgY29uc3QgbGVmdCA9IFt1bmRlZmluZWQsIC4uLnJhbmtzLnNsaWNlKDAsIHNpemUgLSAxKV1cbiAgY29uc3QgcmlnaHQgPSBbLi4ucmFua3Muc2xpY2UoMSksIHVuZGVmaW5lZF1cbiAgcmV0dXJuIHppcChsZWZ0LCByaWdodCkubWFwKChbbCwgcl0pID0+IHtcbiAgICBpZiAobCAhPT0gdW5kZWZpbmVkICYmIHIgIT09IHVuZGVmaW5lZCkgcmV0dXJuIFtsLCByXVxuICAgIGlmIChsICE9PSB1bmRlZmluZWQgJiYgciA9PT0gdW5kZWZpbmVkKSByZXR1cm4gW2xdXG4gICAgaWYgKGwgPT09IHVuZGVmaW5lZCAmJiByICE9PSB1bmRlZmluZWQpIHJldHVybiBbcl1cbiAgICByZXR1cm4gW10gLy8gdGhpcyBzaG91bGQgcmVhbGx5IG9ubHkgaGFwcGVuIHdoZW4gc2l6ZSA9PT0gMVxuICB9KVxufVxuXG5jb25zdCB1dGlsQyA9IChvcHRpb25zOiBPcHRpb25zKSA9PiB7XG4gIGNvbnN0IHsgQkVUQVNRIH0gPSBjb25zdGFudHMob3B0aW9ucylcbiAgcmV0dXJuICh0ZWFtUmF0aW5nczogVGVhbVJhdGluZ1tdKSA9PlxuICAgIE1hdGguc3FydCh0ZWFtUmF0aW5ncy5tYXAoKFtfdGVhbU11LCB0ZWFtU2lnbWFTcSwgX3RlYW0sIF9yYW5rXSkgPT4gdGVhbVNpZ21hU3EgKyBCRVRBU1EpLnJlZHVjZShzdW0sIDApKVxufVxuXG5leHBvcnQgY29uc3QgdXRpbFN1bVEgPSAodGVhbVJhdGluZ3M6IFRlYW1SYXRpbmdbXSwgYzogbnVtYmVyKSA9PlxuICB0ZWFtUmF0aW5ncy5tYXAoKFtfcU11LCBfcVNpZ21hU3EsIF9xVGVhbSwgcVJhbmtdKSA9PlxuICAgIHRlYW1SYXRpbmdzXG4gICAgICAuZmlsdGVyKChbX2lNdSwgX2lTaWdtYVNxLCBfaVRlYW0sIGlSYW5rXSkgPT4gaVJhbmsgPj0gcVJhbmspXG4gICAgICAubWFwKChbaU11LCBfaVNpZ21hU3EsIF9pVGVhbSwgX2lSYW5rXSkgPT4gTWF0aC5leHAoaU11IC8gYykpXG4gICAgICAucmVkdWNlKHN1bSwgMClcbiAgKVxuXG5leHBvcnQgY29uc3QgdXRpbEEgPSAodGVhbVJhdGluZ3M6IFRlYW1SYXRpbmdbXSkgPT5cbiAgdGVhbVJhdGluZ3MubWFwKFxuICAgIChbX2lNdSwgX2lTaWdtYVNxLCBfaVRlYW0sIGlSYW5rXSkgPT5cbiAgICAgIHRlYW1SYXRpbmdzLmZpbHRlcigoW19xTXUsIF9xU2lnbWFTcSwgX3FUZWFtLCBxUmFua10pID0+IGlSYW5rID09PSBxUmFuaykubGVuZ3RoXG4gIClcblxuZXhwb3J0IGNvbnN0IGdhbW1hID0gKG9wdGlvbnM6IE9wdGlvbnMpOiBHYW1tYSA9PlxuICBvcHRpb25zLmdhbW1hID8/XG4gIC8vIGRlZmF1bHQgdG8gaVNpZ21hIC8gY1xuICAoKGM6IG51bWJlciwgX2s6IG51bWJlciwgX211OiBudW1iZXIsIHNpZ21hU3E6IG51bWJlciwgX3RlYW06IFJhdGluZ1tdLCBfcVJhbms6IG51bWJlcikgPT4gTWF0aC5zcXJ0KHNpZ21hU3EpIC8gYylcblxuZXhwb3J0IGRlZmF1bHQgKG9wdGlvbnM6IE9wdGlvbnMpID0+ICh7XG4gIHV0aWxDOiB1dGlsQyhvcHRpb25zKSxcbiAgdGVhbVJhdGluZzogdGVhbVJhdGluZyhvcHRpb25zKSxcbiAgZ2FtbWE6IGdhbW1hKG9wdGlvbnMpLFxufSlcbiIsICJpbXBvcnQgdXRpbCwgeyB1dGlsU3VtUSwgdXRpbEEgfSBmcm9tICcuLi91dGlsJ1xuaW1wb3J0IGNvbnN0YW50cyBmcm9tICcuLi9jb25zdGFudHMnXG5pbXBvcnQgeyBSYXRpbmcsIE9wdGlvbnMsIE1vZGVsIH0gZnJvbSAnLi4vdHlwZXMnXG5cbmNvbnN0IG1vZGVsOiBNb2RlbCA9IChnYW1lOiBSYXRpbmdbXVtdLCBvcHRpb25zOiBPcHRpb25zID0ge30pID0+IHtcbiAgY29uc3QgeyBFUFNJTE9OIH0gPSBjb25zdGFudHMob3B0aW9ucylcbiAgY29uc3QgeyB1dGlsQywgdGVhbVJhdGluZywgZ2FtbWEgfSA9IHV0aWwob3B0aW9ucylcbiAgY29uc3QgdGVhbVJhdGluZ3MgPSB0ZWFtUmF0aW5nKGdhbWUpXG4gIGNvbnN0IGMgPSB1dGlsQyh0ZWFtUmF0aW5ncylcbiAgY29uc3Qgc3VtUSA9IHV0aWxTdW1RKHRlYW1SYXRpbmdzLCBjKVxuICBjb25zdCBhID0gdXRpbEEodGVhbVJhdGluZ3MpXG5cbiAgcmV0dXJuIHRlYW1SYXRpbmdzLm1hcCgoaVRlYW1SYXRpbmcsIGkpID0+IHtcbiAgICBjb25zdCBbaU11LCBpU2lnbWFTcSwgaVRlYW0sIGlSYW5rXSA9IGlUZWFtUmF0aW5nXG4gICAgY29uc3QgaU11T3ZlckNlID0gTWF0aC5leHAoaU11IC8gYykgLy8gdG1wMVxuICAgIGNvbnN0IFtvbWVnYVN1bSwgZGVsdGFTdW1dID0gdGVhbVJhdGluZ3NcbiAgICAgIC5maWx0ZXIoKFtfcU11LCBfcVNpZ21hU3EsIF9xVGVhbSwgcVJhbmtdKSA9PiBxUmFuayA8PSBpUmFuaylcbiAgICAgIC5yZWR1Y2UoXG4gICAgICAgIChbb21lZ2EsIGRlbHRhXSwgW19dLCBxKSA9PiB7XG4gICAgICAgICAgY29uc3QgcXVvdGllbnQgPSBpTXVPdmVyQ2UgLyBzdW1RW3FdXG4gICAgICAgICAgcmV0dXJuIFtvbWVnYSArIChpID09PSBxID8gMSAtIHF1b3RpZW50IDogLXF1b3RpZW50KSAvIGFbcV0sIGRlbHRhICsgKHF1b3RpZW50ICogKDEgLSBxdW90aWVudCkpIC8gYVtxXV1cbiAgICAgICAgfSxcbiAgICAgICAgWzAsIDBdXG4gICAgICApXG5cbiAgICBjb25zdCBpR2FtbWEgPSBnYW1tYShjLCB0ZWFtUmF0aW5ncy5sZW5ndGgsIC4uLmlUZWFtUmF0aW5nKVxuICAgIGNvbnN0IGlPbWVnYSA9IG9tZWdhU3VtICogKGlTaWdtYVNxIC8gYylcbiAgICBjb25zdCBpRGVsdGEgPSBpR2FtbWEgKiBkZWx0YVN1bSAqIChpU2lnbWFTcSAvIGMgKiogMilcblxuICAgIHJldHVybiBpVGVhbS5tYXAoKHsgbXUsIHNpZ21hIH0pID0+ICh7XG4gICAgICBtdTogbXUgKyAoc2lnbWEgKiogMiAvIGlTaWdtYVNxKSAqIGlPbWVnYSxcbiAgICAgIHNpZ21hOiBzaWdtYSAqIE1hdGguc3FydChNYXRoLm1heCgxIC0gKHNpZ21hICoqIDIgLyBpU2lnbWFTcSkgKiBpRGVsdGEsIEVQU0lMT04pKSxcbiAgICB9KSlcbiAgfSlcbn1cblxuZXhwb3J0IGRlZmF1bHQgbW9kZWxcbiIsICJpbXBvcnQgZ2F1c3NpYW4gZnJvbSAnZ2F1c3NpYW4nXG5cbi8vIHVzZSBhIHN0YW5kYXJkIG5vcm1hbCBkaXN0cmlidXRpb24gLSBtZWFuIG9mIHplcm8sIHN0ZGRldi92YXJpYW5jZSBvZiBvbmVcbmNvbnN0IG5vcm1hbCA9IGdhdXNzaWFuKDAsIDEpXG5cbmV4cG9ydCBjb25zdCBwaGlNYWpvciA9ICh4OiBudW1iZXIpID0+IG5vcm1hbC5jZGYoeClcblxuZXhwb3J0IGNvbnN0IHBoaU1ham9ySW52ZXJzZSA9ICh4OiBudW1iZXIpID0+IG5vcm1hbC5wcGYoeClcblxuZXhwb3J0IGNvbnN0IHBoaU1pbm9yID0gKHg6IG51bWJlcikgPT4gbm9ybWFsLnBkZih4KVxuXG5leHBvcnQgY29uc3QgdiA9ICh4OiBudW1iZXIsIHQ6IG51bWJlcikgPT4ge1xuICBjb25zdCB4dCA9IHggLSB0XG4gIGNvbnN0IGRlbm9tID0gcGhpTWFqb3IoeHQpXG4gIHJldHVybiBkZW5vbSA8IE51bWJlci5FUFNJTE9OID8gLXh0IDogcGhpTWlub3IoeHQpIC8gZGVub21cbn1cblxuZXhwb3J0IGNvbnN0IHcgPSAoeDogbnVtYmVyLCB0OiBudW1iZXIpID0+IHtcbiAgY29uc3QgeHQgPSB4IC0gdFxuICBjb25zdCBkZW5vbSA9IHBoaU1ham9yKHh0KVxuICBpZiAoZGVub20gPCBOdW1iZXIuRVBTSUxPTikge1xuICAgIHJldHVybiB4IDwgMCA/IDEgOiAwXG4gIH1cbiAgcmV0dXJuIHYoeCwgdCkgKiAodih4LCB0KSArIHh0KVxufVxuXG5leHBvcnQgY29uc3QgdnQgPSAoeDogbnVtYmVyLCB0OiBudW1iZXIpID0+IHtcbiAgY29uc3QgeHggPSBNYXRoLmFicyh4KVxuICBjb25zdCBiID0gcGhpTWFqb3IodCAtIHh4KSAtIHBoaU1ham9yKC10IC0geHgpXG4gIGlmIChiIDwgMWUtNSkge1xuICAgIGlmICh4IDwgMCkgcmV0dXJuIC14IC0gdFxuICAgIHJldHVybiAteCArIHRcbiAgfVxuICBjb25zdCBhID0gcGhpTWlub3IoLXQgLSB4eCkgLSBwaGlNaW5vcih0IC0geHgpXG4gIHJldHVybiAoeCA8IDAgPyAtYSA6IGEpIC8gYlxufVxuXG5leHBvcnQgY29uc3Qgd3QgPSAoeDogbnVtYmVyLCB0OiBudW1iZXIpID0+IHtcbiAgY29uc3QgeHggPSBNYXRoLmFicyh4KVxuICBjb25zdCBiID0gcGhpTWFqb3IodCAtIHh4KSAtIHBoaU1ham9yKC10IC0geHgpXG4gIHJldHVybiBiIDwgTnVtYmVyLkVQU0lMT05cbiAgICA/IDEuMFxuICAgIDogKCh0IC0geHgpICogcGhpTWlub3IodCAtIHh4KSArICh0ICsgeHgpICogcGhpTWlub3IoLXQgLSB4eCkpIC8gYiArIHZ0KHgsIHQpICogdnQoeCwgdClcbn1cbiIsICJpbXBvcnQgY29uc3RhbnRzIGZyb20gJy4vY29uc3RhbnRzJ1xuaW1wb3J0IHsgUmF0aW5nLCBPcHRpb25zIH0gZnJvbSAnLi90eXBlcydcblxuY29uc3Qgb3JkaW5hbCA9IChyYXRpbmc6IFJhdGluZywgb3B0aW9uczogT3B0aW9ucyA9IHt9KTogbnVtYmVyID0+IHtcbiAgY29uc3QgeyBzaWdtYSwgbXUgfSA9IHJhdGluZ1xuICBjb25zdCB7IFogfSA9IGNvbnN0YW50cyhvcHRpb25zKVxuICByZXR1cm4gbXUgLSBaICogc2lnbWFcbn1cblxuZXhwb3J0IGRlZmF1bHQgb3JkaW5hbFxuIiwgImltcG9ydCBjb25zdGFudHMgZnJvbSAnLi9jb25zdGFudHMnXG5pbXBvcnQgdXRpbCwgeyBzdW0gfSBmcm9tICcuL3V0aWwnXG5pbXBvcnQgeyBwaGlNYWpvciB9IGZyb20gJy4vc3RhdGlzdGljcydcbmltcG9ydCB7IE9wdGlvbnMsIFRlYW0gfSBmcm9tICcuL3R5cGVzJ1xuXG5jb25zdCBwcmVkaWN0V2luID0gKHRlYW1zOiBUZWFtW10sIG9wdGlvbnM6IE9wdGlvbnMgPSB7fSkgPT4ge1xuICBjb25zdCB7IHRlYW1SYXRpbmcgfSA9IHV0aWwob3B0aW9ucylcbiAgY29uc3QgeyBCRVRBU1EgfSA9IGNvbnN0YW50cyhvcHRpb25zKVxuXG4gIGNvbnN0IHRlYW1SYXRpbmdzID0gdGVhbVJhdGluZyh0ZWFtcylcbiAgY29uc3QgbiA9IHRlYW1zLmxlbmd0aFxuICBjb25zdCBkZW5vbSA9IChuICogKG4gLSAxKSkgLyAyXG5cbiAgcmV0dXJuIHRlYW1SYXRpbmdzLm1hcChcbiAgICAoW211QSwgc2lnbWFTcUFdLCBpKSA9PlxuICAgICAgdGVhbVJhdGluZ3NcbiAgICAgICAgLmZpbHRlcigoXywgcSkgPT4gaSAhPT0gcSlcbiAgICAgICAgLm1hcCgoW211Qiwgc2lnbWFTcUJdKSA9PiBwaGlNYWpvcigobXVBIC0gbXVCKSAvIE1hdGguc3FydChuICogQkVUQVNRICsgc2lnbWFTcUEgKyBzaWdtYVNxQikpKVxuICAgICAgICAucmVkdWNlKHN1bSwgMCkgLyBkZW5vbVxuICApXG59XG5cbmV4cG9ydCBkZWZhdWx0IHByZWRpY3RXaW5cbiIsICJpbXBvcnQgeyBmbGF0dGVuLCBzdW0sIG1hcCwgYWRkSW5kZXgsIHJlZHVjZSwgaGVhZCB9IGZyb20gJ3JhbWRhJ1xuaW1wb3J0IGNvbnN0YW50cyBmcm9tICcuL2NvbnN0YW50cydcbmltcG9ydCB1dGlsLCB7IFRlYW1SYXRpbmcgfSBmcm9tICcuL3V0aWwnXG5pbXBvcnQgeyBwaGlNYWpvciwgcGhpTWFqb3JJbnZlcnNlIH0gZnJvbSAnLi9zdGF0aXN0aWNzJ1xuaW1wb3J0IHsgT3B0aW9ucywgVGVhbSB9IGZyb20gJy4vdHlwZXMnXG5cbmNvbnN0IHByZWRpY3REcmF3ID0gKHRlYW1zOiBUZWFtW10sIG9wdGlvbnM6IE9wdGlvbnMgPSB7fSk6IG51bWJlciA9PiB7XG4gIGNvbnN0IHsgdGVhbVJhdGluZyB9ID0gdXRpbChvcHRpb25zKVxuICBjb25zdCB7IEJFVEFTUSwgQkVUQSB9ID0gY29uc3RhbnRzKG9wdGlvbnMpXG5cbiAgY29uc3QgdG90YWxQbGF5ZXJDb3VudCA9IGZsYXR0ZW4odGVhbXMpLmxlbmd0aFxuICBjb25zdCBkcmF3UHJvYmFiaWxpdHkgPSAxIC8gdG90YWxQbGF5ZXJDb3VudFxuICBjb25zdCBkcmF3TWFyZ2luID0gTWF0aC5zcXJ0KHRvdGFsUGxheWVyQ291bnQpICogQkVUQSAqIHBoaU1ham9ySW52ZXJzZSgoMSArIGRyYXdQcm9iYWJpbGl0eSkgLyAyKVxuXG4gIGNvbnN0IHRlYW1SYXRpbmdzID0gbWFwPFRlYW0sIFRlYW1SYXRpbmc+KCh0ZWFtKSA9PiBoZWFkPFRlYW1SYXRpbmc+KHRlYW1SYXRpbmcoW3RlYW1dKSkhLCB0ZWFtcylcblxuICBjb25zdCBwYWlyd2lzZVByb2JzOiBudW1iZXJbXSA9IGFkZEluZGV4PFRlYW1SYXRpbmcsIG51bWJlcltdPihyZWR1Y2U8VGVhbVJhdGluZywgbnVtYmVyW10+KShcbiAgICAob3V0ZXJBY2N1bTogbnVtYmVyW10sIHBhaXJBOiBUZWFtUmF0aW5nLCBpOiBudW1iZXIpOiBudW1iZXJbXSA9PiB7XG4gICAgICBjb25zdCBbbXVBLCBzaWdtYVNxQV0gPSBwYWlyQVxuICAgICAgcmV0dXJuIHJlZHVjZTxUZWFtUmF0aW5nLCBudW1iZXJbXT4oXG4gICAgICAgIChpbm5lckFjY3VtOiBudW1iZXJbXSwgcGFpckI6IFRlYW1SYXRpbmcpOiBudW1iZXJbXSA9PiB7XG4gICAgICAgICAgY29uc3QgW211Qiwgc2lnbWFTcUJdID0gcGFpckJcbiAgICAgICAgICBjb25zdCBzaGFyZWREZW5vbSA9IE1hdGguc3FydCh0b3RhbFBsYXllckNvdW50ICogQkVUQVNRICsgc2lnbWFTcUEgKyBzaWdtYVNxQilcbiAgICAgICAgICBpbm5lckFjY3VtLnB1c2goXG4gICAgICAgICAgICBwaGlNYWpvcigoZHJhd01hcmdpbiAtIG11QSArIG11QikgLyBzaGFyZWREZW5vbSkgLSBwaGlNYWpvcigobXVCIC0gbXVBIC0gZHJhd01hcmdpbikgLyBzaGFyZWREZW5vbSlcbiAgICAgICAgICApXG4gICAgICAgICAgcmV0dXJuIGlubmVyQWNjdW1cbiAgICAgICAgfSxcbiAgICAgICAgb3V0ZXJBY2N1bSxcbiAgICAgICAgdGVhbVJhdGluZ3Muc2xpY2UoaSArIDEpXG4gICAgICApXG4gICAgfSxcbiAgICBbXSxcbiAgICB0ZWFtUmF0aW5nc1xuICApXG5cbiAgcmV0dXJuIHN1bShwYWlyd2lzZVByb2JzKSAvIHBhaXJ3aXNlUHJvYnMubGVuZ3RoXG59XG5cbmV4cG9ydCBkZWZhdWx0IHByZWRpY3REcmF3XG4iXSwKICAibWFwcGluZ3MiOiAiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7O0FDRUEsSUFBTSxVQUFVLENBQUMsWUFBcUI7QUFFcEMsUUFBTSxFQUFFLElBQUksR0FBRyxLQUFLLElBQUksdUJBQXVCLE9BQU8sVUFBVSxLQUFPLElBQUk7QUFDM0UsUUFBTSxFQUFFLE1BQU0sS0FBSyxLQUFLLFFBQVEsS0FBSyxHQUFHLE9BQU8sUUFBUSxHQUFHLGFBQWEscUJBQXFCLElBQUk7QUFDaEcsUUFBTSxTQUFTLFFBQVE7QUFFdkIsU0FBTztBQUFBLElBQ0wsT0FBTztBQUFBLElBQ1AsSUFBSTtBQUFBLElBQ0osU0FBUztBQUFBLElBQ1QsV0FBVyxJQUFJO0FBQUEsSUFDZixNQUFNO0FBQUEsSUFDTixRQUFRO0FBQUEsSUFDUixHQUFHO0FBQUEsSUFDSCxLQUFLO0FBQUEsSUFDTCxhQUFhO0FBQUEsRUFDZjtBQUNGO0FBRUEsSUFBTyxvQkFBUTs7O0FDbEJmLElBQU0sU0FBUyxDQUFDLE1BQXdDLFVBQW1CLENBQUMsTUFBYztBQUN4RixRQUFNLEVBQUUsSUFBSSxJQUFJLE9BQU8sTUFBTSxJQUFJ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QkFBc0IsQ0FBQyxhQUFTLG9CQUFpQkEsWUFBVyxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUksS0FBSztBQUVoRyxRQUFNLG9CQUEwQix3QkFBK0Isb0JBQTRCO0FBQUEsSUFDekYsQ0FBQyxZQUFzQixPQUFtQixNQUF3QjtBQUNoRSxZQUFNLENBQUMsS0FBSyxRQUFRLElBQUk7QUFDeEIsaUJBQU87QUFBQSxRQUNMLENBQUMsWUFBc0IsVUFBZ0M7QUFDckQsZ0JBQU0sQ0FBQyxLQUFLLFFBQVEsSUFBSTtBQUN4QixnQkFBTSxjQUFjLEtBQUssS0FBSyxtQkFBbUIsU0FBUyxXQUFXLFFBQVE7QUFDN0UscUJBQVc7QUFBQSxZQUNULFVBQVUsYUFBYSxNQUFNLE9BQU8sV0FBVyxJQUFJLFVBQVUsTUFBTSxNQUFNLGNBQWMsV0FBVztBQUFBLFVBQ3BHO0FBQ0EsaUJBQU87QUFBQSxRQUNUO0FBQUEsUUFDQTtBQUFBLFFBQ0EsWUFBWSxNQUFNLElBQUksQ0FBQztBQUFBLE1BQ3pCO0FBQUEsSUFDRjtBQUFBLElBQ0EsQ0FBQztBQUFBLElBQ0Q7QUFBQSxFQUNGO0FBRUEsYUFBTyxtQkFBSSxhQUFhLElBQUksY0FBYztBQUM1QztBQUVBLElBQU8sdUJBQVE7IiwKICAibmFtZXMiOiBbImltcG9ydF9yYW1kYSIsICJ1dGlsQyIsICJ0ZWFtUmF0aW5nIiwgImdhbW1hIiwgImdhdXNzaWFuIiwgIm1vZGVsIiwgInJhdGluZyIsICJ0ZWFtUmF0aW5nIiwgImltcG9ydF9yYW1kYSIsICJ0ZWFtUmF0aW5nIl0KfQo=